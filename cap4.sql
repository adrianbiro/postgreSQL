/*Data types
v SQL je na je mozne mat iba jeden data type na column*/

CREATE TABLE eagle_watch (
	observation_date DATE,
	eagles_seen INTEGER,
	notes TEXT
);

/*
CHAR(n)
VARCHAR(n)  da sa specivikovat to hore cez CHARACTER VARYING(n)
TEXT unlimited lenght up to 1 gigabyte in postgres, not in SQL standard
-- vsetky maju podobnu performance, ale ma racio specifikovat
napr. CHAR(2) pre US postal abbreviations a podobne nemenne veci.
*/

CREATE TABLE char_data_types (
	char_column CHAR(10),
	varchar_column VARCHAR(10),
	text_column TEXT
);

INSERT INTO char_data_types
VALUES
	('abc', 'abc', 'abc'),
	('defghi', 'defghi', 'defghi');
	
/*export database to file, user postgres nema pristup v $HOME tak toto je jednoduchsie*/
COPY char_data_types TO '/tmp/typetestcap3.txt'
WITH (FORMAT CSV, HEADER, DELIMITER '|')

/*Numbers
Integers, Fixed-point, Floating_point
SMALLINT	- 2 bytes	−32768 to +32767
INTEGER		- 4 bytes	−2147483648 to +2147483647
BIGINT		- 8 bytes	−9223372036854775808 to +9223372036854775807
-- pre datum a male veci staci SMALLINT

----------------------
Auto-Incrementing Integers
SMALLSERIAL 	2 bytes		1 to 32767
SERIAL			4 bytes		1 to 2147483647
BIGSERIAL		8 bytes		1 to 9223372036854775807
*/
CREATE TABLE people (
	id SERIAL,
	person_name VARCHAR(100)
);

/*IDENTITY
-- je to SQL standard od postgres10 je tu
je dobre pre kompatibilitu s Oracle
GENERATED ALWAYS AS IDENTITY
	- toto zabranipouzivatelovi vlozit hodnotu
GENERATED BY DEFAULT AS IDENTITY
	-- toto dovoli stanovit vlastnu, ak nie je tak generuje

ked sa row zmaze samo od seba sa pocinanie nezresetuje ale bude pokracovat ako je
*/
CREATE TABLE people (
	id integer GENERATED ALWAYS AS IDENTITY,
	person_name VARCHAR(100)
);

INSERT INTO people (person_name)
VALUES
	('Valora'),
	('Rana');
/*toto bude zle
INSERT INTO people (id, person_name)
VALUES(9, 'top');
*/
SELECT *
FROM people;

/*Decimal numbers
NUMERIC, DECIMAL	variable storage size	Fixed-point 	Up to 131,072 digit 
					before decimalpoint; up to 16,383 digits afret decimal point
REAL				4 bytes					floating-point	6 decimal digit precisiion
DOUBLE PRECISION	8 bytes					Floating-point	15 decimal digits precision
*/

CREATE TABLE number_data_types (
	numeric_column NUMERIC(20,5),
	real_column REAL,
	double_column DOUBLE PRECISION
);

INSERT INTO number_data_types
VALUES
	(.7,.7,.7),
	(2.13579, 2.13579, 2.13579),
	(2.1357987654, 2.1357987654, 2.1357987654);
	
SELECT * FROM number_data_types;

/* toto spravi chybu s floatom
SELECT
    numeric_column * 10000000 AS fixed,
    real_column * 10000000 AS floating
FROM number_data_types
WHERE numeric_column = .7;
*/
------------
/*Dates and Times*/

/*
	timestamp	8 bytes	Date and time	4713 BC to 294276 AD
	date	4 bytes	Date (no time)	4713 BC to 5874897 AD
	time	8 bytes	Time (no date)	00:00:00 to 24:00:00
	interval	16 bytes	Time interval	+/− 178,000,000 years

TIMESTAMP 	-- TIMESTAMP WITH TIME ZONE je SQL postgres TIMESTAMPTZ
DATE
TIME		-- TIME WITH TIMEZONE
INTERVAL	-- suhrny casovy inteval 12 days 8 hours
*/

CREATE TABLE date_time_types(
	timestamp_column TIMESTAMP WITH TIME ZONE,
	interval_column	INTERVAL
);

INSERT INTO date_time_types
VALUES
	('2022-12-31 01:00 EST','2 days'),
    ('2022-12-31 01:00 -8','1 month'),
    ('2022-12-31 01:00 Australia/Melbourne','1 century'),
    (now(),'1 week');

SELECT * FROM date_time_types;

/*Calculation with intervala data type*/

/*odcitaj od timestamp interval*/
SELECT
	timestamp_column,
	interval_column,
	timestamp_column - interval_column AS new_date  -- defaultne to bude TIMESTAMP WITH TIME ZONE
FROM date_time_types;

/*JSON in postgres
json	-- Stores an exact copy of JSON text
jsonb	-- Storej JSON as binary format
	-- jsonb umoznuje indexovanie
*/

--------
/*Ostatne typy
BOOLEAN 			true false
GEOMETRIC TYPES 	points, lines, circles, two-dimensional objects
TEXT SEARCH TYPES	full text search engine
NETWORK ADDRESS TYPES	IP a MAC
UUID	universally uniqie identifier
RANGE TYPES			intiger timestamps
TYPES for storing BINARY data
XML			pre strukturovane ukladanie informacii
*/

-----
/*CASTING values*/
SELECT timestamp_column, CAST(timestamp_column AS VARCHAR(10))  -- oreze to a ukaze len zaciatok teda datum nie cas
FROM date_time_types;

SELECT numeric_column,
	CAST(numeric_column AS INTEGER),
	CAST(numeric_column AS TEXT)
FROM number_data_types;

/*postgres skratka na zapis cast cez ::*/
SELECT timestamp_column, CAST(timestamp_column AS VARCHAR(10))
FROM date_time_types;
SELECT timestamp_column::VARCHAR(10)
FROM date_time_types;

-- TODO uloha na konci





